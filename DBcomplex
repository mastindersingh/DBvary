
def process_postgresql_kpi(kpi, db, current_date, next_date, kpi_tracking_data):
    # Grab the query template from kpi["query_text"] or wherever you store it
    query_template = kpi["query_text"]
    
    # Convert Python datetime objects to strings in your desired format
    # e.g., "YYYY/MM/DD HH:MM"
    start_str = current_date.strftime("%Y/%m/%d %H:%M")
    end_str = next_date.strftime("%Y/%m/%d %H:%M")

    # For the previous month date, do your own logic to compute it:
    # Example:
    prev_month = current_date.replace(day=1) - timedelta(days=1)
    prev_month_date_str = prev_month.strftime("%Y/%m/%d %H:%M")

    # Replace placeholders
    query = (
        query_template
        .replace("{start_date}", start_str)
        .replace("{end_date}", end_str)
        .replace("{prev_month_date}", prev_month_date_str)
    )

    logger.info("Executing PostgreSQL query: %s", query)
    results = db.execute_query(query)

    # Process results as needed
    for row in results:
        # Adjust indexes to match your columns (APP_ID, DB_SERVICENOW_ID, etc.)
        app_id = row[0]
        db_servicenow_id = row[1]
        report_date = row[2]
        
        # Append to tracking data




def process_sql_server_kpi(kpi, mssql, current_date, next_date, kpi_tracking_data):
    """
    Process KPI data from SQL Server for a given date range.
    """
    # Ensure current_date is a datetime object
    if not isinstance(current_date, datetime):
        raise ValueError("current_date must be a datetime object")

    # Calculate the previous month's start date
    first_day_current_month = current_date.replace(day=1)
    prev_month_start = first_day_current_month - timedelta(days=1)
    prev_month_start = prev_month_start.replace(day=1, hour=0, minute=0, second=0, microsecond=0, tzinfo=timezone.utc)

    print(f"Calculated prev_month_start: {prev_month_start}")  # Debugging output

    # Ensure prev_month_start is a string before replacing
    if not isinstance(prev_month_start, datetime):
        raise TypeError(f"prev_month_start is not a datetime object: {type(prev_month_start)}")

    # Debug raw query
    print(f"Raw Query: {kpi['query_text']}")

    # Replace placeholders in query
    query = kpi["query_text"]
    query = query.replace("{start_date}", current_date.strftime("%Y/%m/%d %H:%M"))
    print(f"After start_date replacement: {query}")

    query = query.replace("{end_date}", next_date.strftime("%Y/%m/%d %H:%M"))
    print(f"After end_date replacement: {query}")

    query = query.replace("{prev_month_start}", prev_month_start.strftime("%Y/%m/%d %H:%M"))
    print(f"After prev_month_start replacement: {query}")

    # Print the query for debugging
    logger.info(f"Executing query: {query}")
    print(f"Executing query: {query}")  # Debugging output

    # Execute the query
    results = mssql.execute_query(query)

    return results



SELECT
    '{start_date}'::timestamp AS start_date,
    '{end_date}'::timestamp AS end_date,
    '{prev_month_start}'::timestamp AS prev_month_start,
    "APP_ID",
    "DB_SERVICENOW_ID",
    "REPORT_DATE"
FROM (
    SELECT DISTINCT
        "DB_SERVICENOW_ID",
        "REPORT_DATE",
        "ENCRYPTED",
        "APP_ID",
        "JIRA_TICKET_NUMBER"
    FROM (
        SELECT
            FIRST_VALUE("REPORT_DATE") OVER (
                PARTITION BY "DB_SERVICENOW_ID", "ENCRYPTED"
                ORDER BY "REPORT_DATE" DESC
            ) AS "REPORT_DATE",
            "JIRA_TICKET_NUMBER",
            "APP_ID"
        FROM "PSI_AUTOMATION"."DATABASE_ENCRYPTION_HISTORY"
        WHERE "REPORT_DATE" BETWEEN '{prev_month_start}' AND '{end_date}'
          AND "JIRA_TICKET_NUMBER" IS NOT NULL
    ) x
) y
WHERE "ENCRYPTED" = '1'
  AND "REPORT_DATE" BETWEEN '{prev_month_start}' AND '{end_date}';

